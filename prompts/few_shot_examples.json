{
  "stage1_examples": [
    {
      "description": "Simple function - auto-confirm",
      "function_code": "def add(a: int, b: int) -> int:\n    \"\"\"Add two integers.\"\"\"\n    return a + b",
      "user_description": "Test basic addition functionality",
      "expected_output": {
        "skip_confirmation": true,
        "proceed_to_generation": true,
        "identified_scenarios": [
          {
            "scenario": "Add two positive integers and verify the sum",
            "confidence": "high",
            "source": "code_analysis"
          },
          {
            "scenario": "Add positive and negative integers",
            "confidence": "high",
            "source": "inference"
          },
          {
            "scenario": "Add two negative integers",
            "confidence": "medium",
            "source": "inference"
          },
          {
            "scenario": "Add with zero values",
            "confidence": "medium",
            "source": "inference"
          }
        ],
        "suggested_additional_scenarios": [],
        "confirmation_question": "",
        "reason": "Simple function with no branches or exceptions, straightforward operation"
      }
    },
    {
      "description": "Complex function with brief user description - needs confirmation",
      "function_code": "def process_payment(amount: float, payment_method: str) -> dict:\n    \"\"\"Process a payment transaction.\"\"\"\n    if amount <= 0:\n        raise ValueError(\"Amount must be positive\")\n    \n    if payment_method == \"credit_card\":\n        return {\"status\": \"success\", \"fee\": amount * 0.03}\n    elif payment_method == \"paypal\":\n        return {\"status\": \"success\", \"fee\": amount * 0.05}\n    else:\n        raise ValueError(\"Invalid payment method\")",
      "user_description": "Test payment processing function",
      "expected_output": {
        "skip_confirmation": false,
        "proceed_to_generation": true,
        "identified_scenarios": [
          {
            "scenario": "Process successful credit card payment with 3% fee calculation",
            "confidence": "high",
            "source": "code_analysis"
          },
          {
            "scenario": "Process successful PayPal payment with 5% fee calculation",
            "confidence": "high",
            "source": "code_analysis"
          },
          {
            "scenario": "Reject payment with negative or zero amount",
            "confidence": "high",
            "source": "code_analysis"
          },
          {
            "scenario": "Reject payment with invalid payment method",
            "confidence": "high",
            "source": "code_analysis"
          }
        ],
        "suggested_additional_scenarios": [
          {
            "scenario": "Handle very large payment amounts (boundary testing)",
            "confidence": "medium",
            "source": "inference",
            "reason": "Large amounts might cause floating-point precision issues"
          },
          {
            "scenario": "Handle payment method with different casing (e.g., 'Credit_Card')",
            "confidence": "low",
            "source": "inference",
            "reason": "String comparison is case-sensitive; unclear if this should be handled"
          }
        ],
        "confirmation_question": "I've identified these test scenarios: (1) Successful credit card payment with 3% fee, (2) Successful PayPal payment with 5% fee, (3) Rejection of negative/zero amounts, (4) Rejection of invalid payment methods. Would you like to add any other scenarios, such as specific edge cases for amounts or additional payment methods to test?"
      }
    },
    {
      "description": "Detailed user description - auto-confirm",
      "function_code": "def validate_email(email: str) -> bool:\n    \"\"\"Validate email address format.\"\"\"\n    if not email or '@' not in email:\n        return False\n    return True",
      "user_description": "Test email validation including: valid emails with @ symbol, invalid emails without @, None input, empty string, and emails with multiple @ symbols",
      "expected_output": {
        "skip_confirmation": true,
        "proceed_to_generation": true,
        "identified_scenarios": [
          {
            "scenario": "Return True for valid email with @ symbol",
            "confidence": "high",
            "source": "user_description"
          },
          {
            "scenario": "Return False for email without @ symbol",
            "confidence": "high",
            "source": "user_description"
          },
          {
            "scenario": "Return False for None input",
            "confidence": "high",
            "source": "user_description"
          },
          {
            "scenario": "Return False for empty string",
            "confidence": "high",
            "source": "user_description"
          },
          {
            "scenario": "Handle email with multiple @ symbols",
            "confidence": "high",
            "source": "user_description"
          }
        ],
        "suggested_additional_scenarios": [],
        "confirmation_question": "",
        "reason": "User description comprehensively covers all code paths and edge cases"
      }
    },
    {
      "description": "Function with exception handling - needs confirmation",
      "function_code": "def divide(a: float, b: float) -> float:\n    \"\"\"Divide two numbers.\"\"\"\n    try:\n        return a / b\n    except ZeroDivisionError:\n        raise ValueError(\"Cannot divide by zero\")\n    except TypeError:\n        raise TypeError(\"Both arguments must be numbers\")",
      "user_description": "Test division with various inputs",
      "expected_output": {
        "skip_confirmation": false,
        "proceed_to_generation": true,
        "identified_scenarios": [
          {
            "scenario": "Successfully divide two positive numbers",
            "confidence": "high",
            "source": "code_analysis"
          },
          {
            "scenario": "Divide with negative numbers",
            "confidence": "high",
            "source": "inference"
          },
          {
            "scenario": "Raise ValueError when dividing by zero",
            "confidence": "high",
            "source": "code_analysis"
          },
          {
            "scenario": "Raise TypeError when arguments are not numbers",
            "confidence": "high",
            "source": "code_analysis"
          }
        ],
        "suggested_additional_scenarios": [
          {
            "scenario": "Handle division resulting in infinity (very large numbers)",
            "confidence": "low",
            "source": "inference",
            "reason": "Extreme values might produce inf or -inf"
          },
          {
            "scenario": "Test division with floating-point precision edge cases",
            "confidence": "low",
            "source": "inference",
            "reason": "Some division operations might have precision issues"
          }
        ],
        "confirmation_question": "I've identified these scenarios: (1) Normal division with positive numbers, (2) Division with negative numbers, (3) Division by zero raising ValueError, (4) Invalid argument types raising TypeError. Are there any specific numeric edge cases or additional scenarios you'd like to test?"
      }
    }
  ],
  "stage2_examples": [
    {
      "description": "Simple add function with basic tests",
      "function_code": "def add(a: int, b: int) -> int:\n    \"\"\"Add two integers.\"\"\"\n    return a + b",
      "confirmed_scenarios": [
        {
          "scenario": "Add two positive integers and verify the sum",
          "confidence": "high",
          "source": "code_analysis"
        },
        {
          "scenario": "Add positive and negative integers",
          "confidence": "high",
          "source": "inference"
        },
        {
          "scenario": "Add with zero values",
          "confidence": "medium",
          "source": "inference"
        }
      ],
      "expected_test_code": "import pytest\nfrom calculator import add\n\n\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (2, 3, 5),\n    (10, 20, 30),\n    (100, 200, 300),\n])\ndef test_should_return_correct_sum_when_adding_positive_integers(a, b, expected):\n    \"\"\"Test that add returns correct sum for positive integers.\"\"\"\n    result = add(a, b)\n    assert result == expected\n\n\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (5, -3, 2),\n    (-5, 3, -2),\n    (10, -10, 0),\n])\ndef test_should_return_correct_sum_when_adding_positive_and_negative_integers(a, b, expected):\n    \"\"\"Test that add correctly handles positive and negative integers.\"\"\"\n    result = add(a, b)\n    assert result == expected\n\n\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (0, 0, 0),\n    (0, 5, 5),\n    (5, 0, 5),\n])\ndef test_should_return_correct_sum_when_one_or_both_values_are_zero(a, b, expected):\n    \"\"\"Test that add correctly handles zero values.\"\"\"\n    result = add(a, b)\n    assert result == expected\n"
    },
    {
      "description": "Payment processing with exceptions and branches",
      "function_code": "def process_payment(amount: float, payment_method: str) -> dict:\n    \"\"\"Process a payment transaction.\"\"\"\n    if amount <= 0:\n        raise ValueError(\"Amount must be positive\")\n    \n    if payment_method == \"credit_card\":\n        return {\"status\": \"success\", \"fee\": amount * 0.03}\n    elif payment_method == \"paypal\":\n        return {\"status\": \"success\", \"fee\": amount * 0.05}\n    else:\n        raise ValueError(\"Invalid payment method\")",
      "confirmed_scenarios": [
        {
          "scenario": "Process successful credit card payment with 3% fee calculation",
          "confidence": "high",
          "source": "code_analysis"
        },
        {
          "scenario": "Process successful PayPal payment with 5% fee calculation",
          "confidence": "high",
          "source": "code_analysis"
        },
        {
          "scenario": "Reject payment with negative or zero amount",
          "confidence": "high",
          "source": "code_analysis"
        },
        {
          "scenario": "Reject payment with invalid payment method",
          "confidence": "high",
          "source": "code_analysis"
        }
      ],
      "expected_test_code": "import pytest\nfrom payment import process_payment\n\n\ndef test_should_return_success_with_correct_fee_when_using_credit_card():\n    \"\"\"Test that credit card payment processes successfully with 3% fee.\"\"\"\n    # Arrange\n    amount = 100.0\n    payment_method = \"credit_card\"\n    \n    # Act\n    result = process_payment(amount, payment_method)\n    \n    # Assert\n    assert result[\"status\"] == \"success\"\n    assert result[\"fee\"] == pytest.approx(3.0)\n\n\ndef test_should_return_success_with_correct_fee_when_using_paypal():\n    \"\"\"Test that PayPal payment processes successfully with 5% fee.\"\"\"\n    # Arrange\n    amount = 100.0\n    payment_method = \"paypal\"\n    \n    # Act\n    result = process_payment(amount, payment_method)\n    \n    # Assert\n    assert result[\"status\"] == \"success\"\n    assert result[\"fee\"] == pytest.approx(5.0)\n\n\n@pytest.mark.parametrize(\"amount\", [\n    -10.0,\n    -0.01,\n    0.0,\n])\ndef test_should_raise_value_error_when_amount_is_not_positive(amount):\n    \"\"\"Test that non-positive amounts raise ValueError.\"\"\"\n    with pytest.raises(ValueError, match=\"Amount must be positive\"):\n        process_payment(amount, \"credit_card\")\n\n\n@pytest.mark.parametrize(\"payment_method\", [\n    \"bitcoin\",\n    \"cash\",\n    \"debit_card\",\n    \"\",\n])\ndef test_should_raise_value_error_when_payment_method_is_invalid(payment_method):\n    \"\"\"Test that invalid payment methods raise ValueError.\"\"\"\n    with pytest.raises(ValueError, match=\"Invalid payment method\"):\n        process_payment(100.0, payment_method)\n\n\n@pytest.mark.parametrize(\"amount,payment_method,expected_fee_rate\", [\n    (200.0, \"credit_card\", 0.03),\n    (200.0, \"paypal\", 0.05),\n    (50.0, \"credit_card\", 0.03),\n    (50.0, \"paypal\", 0.05),\n])\ndef test_should_calculate_correct_fee_for_different_amounts_and_methods(amount, payment_method, expected_fee_rate):\n    \"\"\"Test fee calculation accuracy for various amounts and payment methods.\"\"\"\n    # Arrange\n    expected_fee = amount * expected_fee_rate\n    \n    # Act\n    result = process_payment(amount, payment_method)\n    \n    # Assert\n    assert result[\"fee\"] == pytest.approx(expected_fee)\n"
    },
    {
      "description": "Email validation with multiple edge cases",
      "function_code": "def validate_email(email: str) -> bool:\n    \"\"\"Validate email address format.\"\"\"\n    if not email or '@' not in email:\n        return False\n    return True",
      "confirmed_scenarios": [
        {
          "scenario": "Return True for valid email with @ symbol",
          "confidence": "high",
          "source": "user_description"
        },
        {
          "scenario": "Return False for email without @ symbol",
          "confidence": "high",
          "source": "user_description"
        },
        {
          "scenario": "Return False for None input",
          "confidence": "high",
          "source": "user_description"
        },
        {
          "scenario": "Return False for empty string",
          "confidence": "high",
          "source": "user_description"
        }
      ],
      "expected_test_code": "import pytest\nfrom validation import validate_email\n\n\n@pytest.mark.parametrize(\"email\", [\n    \"user@example.com\",\n    \"test.user@domain.co.uk\",\n    \"admin@localhost\",\n    \"name+tag@company.com\",\n])\ndef test_should_return_true_when_email_contains_at_symbol(email):\n    \"\"\"Test that validate_email returns True for emails with @ symbol.\"\"\"\n    result = validate_email(email)\n    assert result is True\n\n\n@pytest.mark.parametrize(\"email\", [\n    \"notanemail\",\n    \"missing.at.sign\",\n    \"user.example.com\",\n])\ndef test_should_return_false_when_email_missing_at_symbol(email):\n    \"\"\"Test that validate_email returns False for emails without @ symbol.\"\"\"\n    result = validate_email(email)\n    assert result is False\n\n\ndef test_should_return_false_when_email_is_none():\n    \"\"\"Test that validate_email returns False when given None.\"\"\"\n    result = validate_email(None)\n    assert result is False\n\n\ndef test_should_return_false_when_email_is_empty_string():\n    \"\"\"Test that validate_email returns False for empty string.\"\"\"\n    result = validate_email(\"\")\n    assert result is False\n\n\ndef test_should_handle_email_with_multiple_at_symbols():\n    \"\"\"Test that validate_email handles emails with multiple @ symbols.\"\"\"\n    # Current implementation returns True if @ is present (even multiple)\n    result = validate_email(\"user@@example.com\")\n    assert result is True\n"
    }
  ]
}
